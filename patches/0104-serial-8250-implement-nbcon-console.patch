From: John Ogness <john.ogness@linutronix.de>
Date: Wed, 13 Sep 2023 15:30:36 +0000
Subject: [PATCH 104/107] serial: 8250: implement nbcon console

Implement the necessary callbacks to allow the 8250 console driver
to perform as an nbcon console.

Add implementations for the nbcon consoles (write_atomic, write_thread,
uart_port) and add CON_NBCON to the initial flags.

The legacy callback (write) is kept in order to easily switch back
to legacy mode. But the @oops_in_progress hackery has been removed.

Although nbcon consoles can coexist with legacy consoles, you
will only receive all the benefits of the nbcon consoles if
this console driver is the only console. That means no netconsole,
no tty1, no earlyprintk, no earlycon. Just the uart8250.

For example: console=ttyS0,115200

Signed-off-by: John Ogness <john.ogness@linutronix.de>
Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
---
 drivers/tty/serial/8250/8250_core.c |   18 +++++++++++++++++-
 drivers/tty/serial/8250/8250_port.c |   36 +++++++++++++++++++++++++-----------
 include/linux/serial_8250.h         |    2 ++
 3 files changed, 44 insertions(+), 12 deletions(-)

--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -600,6 +600,19 @@ static void univ8250_console_write(struc
 	serial8250_console_write(up, s, count);
 }
 
+static bool univ8250_console_write_atomic(struct console *co,
+					  struct nbcon_write_context *wctxt)
+{
+	struct uart_8250_port *up = &serial8250_ports[co->index];
+
+	return serial8250_console_write_atomic(up, wctxt);
+}
+
+static struct uart_port *univ8250_console_uart_port(struct console *con)
+{
+	return &serial8250_ports[con->index].port;
+}
+
 static int univ8250_console_setup(struct console *co, char *options)
 {
 	struct uart_8250_port *up;
@@ -699,11 +712,14 @@ static int univ8250_console_match(struct
 static struct console univ8250_console = {
 	.name		= "ttyS",
 	.write		= univ8250_console_write,
+	.write_atomic	= univ8250_console_write_atomic,
+	.write_thread	= univ8250_console_write_atomic,
+	.uart_port	= univ8250_console_uart_port,
 	.device		= uart_console_device,
 	.setup		= univ8250_console_setup,
 	.exit		= univ8250_console_exit,
 	.match		= univ8250_console_match,
-	.flags		= CON_PRINTBUFFER | CON_ANYTIME,
+	.flags		= CON_PRINTBUFFER | CON_ANYTIME | CON_NBCON,
 	.index		= -1,
 	.data		= &serial8250_reg,
 };
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -3394,22 +3394,15 @@ static void serial8250_console_fifo_writ
  *	Doing runtime PM is really a bad idea for the kernel console.
  *	Thus, we assume the function is called when device is powered up.
  */
-void serial8250_console_write(struct uart_8250_port *up, const char *s,
-			      unsigned int count)
+static void __serial8250_console_write(struct uart_8250_port *up, const char *s,
+				       unsigned int count)
 {
 	struct uart_8250_em485 *em485 = up->em485;
 	struct uart_port *port = &up->port;
-	unsigned long flags;
 	unsigned int ier, use_fifo;
-	int locked = 1;
 
 	touch_nmi_watchdog();
 
-	if (oops_in_progress)
-		locked = uart_port_trylock_irqsave(port, &flags);
-	else
-		uart_port_lock_irqsave(port, &flags);
-
 	/*
 	 *	First save the IER then disable the interrupts
 	 */
@@ -3476,9 +3469,30 @@ void serial8250_console_write(struct uar
 	 */
 	if (up->msr_saved_flags)
 		serial8250_modem_status(up);
+}
+
+void serial8250_console_write(struct uart_8250_port *up, const char *s,
+			      unsigned int count)
+{
+	struct uart_port *port = &up->port;
+	unsigned long flags;
+
+	uart_port_lock_irqsave(port, &flags);
+
+	__serial8250_console_write(up, s, count);
+
+	uart_port_unlock_irqrestore(port, flags);
+}
+
+bool serial8250_console_write_atomic(struct uart_8250_port *up,
+				     struct nbcon_write_context *wctxt)
+{
+	if (!nbcon_enter_unsafe(wctxt))
+		return false;
+
+	__serial8250_console_write(up, wctxt->outbuf, wctxt->len);
 
-	if (locked)
-		uart_port_unlock_irqrestore(port, flags);
+	return nbcon_exit_unsafe(wctxt);
 }
 
 static unsigned int probe_baud(struct uart_port *port)
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -204,6 +204,8 @@ void serial8250_init_port(struct uart_82
 void serial8250_set_defaults(struct uart_8250_port *up);
 void serial8250_console_write(struct uart_8250_port *up, const char *s,
 			      unsigned int count);
+bool serial8250_console_write_atomic(struct uart_8250_port *up,
+				     struct nbcon_write_context *wctxt);
 int serial8250_console_setup(struct uart_port *port, char *options, bool probe);
 int serial8250_console_exit(struct uart_port *port);
 
