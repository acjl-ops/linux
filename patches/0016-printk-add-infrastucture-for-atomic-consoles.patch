From: John Ogness <john.ogness@linutronix.de>
Date: Fri, 4 Feb 2022 16:01:17 +0106
Subject: [PATCH 16/18] printk: add infrastucture for atomic consoles

Many times it is not possible to see the console output on
panic because printing threads cannot be scheduled and/or the
console is already taken and forcibly overtaking/busting the
locks does provide the hoped results.

Introduce a new infrastructure to support "atomic consoles".
A new optional callback in struct console, write_atomic(), is
available for consoles to provide an implemention for writing
console messages. The implementation must be NMI safe if they
can run on an architecture where NMIs exist.

Console drivers implementing the write_atomic() callback must
also select CONFIG_HAVE_ATOMIC_CONSOLE in order to enable the
atomic console code within the printk subsystem.

If atomic consoles are available, panic() will flush the kernel
log only to the atomic consoles (before busting spinlocks).
Afterwards, panic() will continue  as before, which includes
attempting to flush the other (non-atomic) consoles.

Signed-off-by: John Ogness <john.ogness@linutronix.de>
Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
---
 include/linux/console.h |   16 ++-
 init/Kconfig            |    4 
 kernel/panic.c          |    6 -
 kernel/printk/printk.c  |  248 +++++++++++++++++++++++++++++++++++++++++++-----
 4 files changed, 249 insertions(+), 25 deletions(-)

--- a/include/linux/console.h
+++ b/include/linux/console.h
@@ -166,6 +166,15 @@ enum cons_flags {
 	CON_EXTENDED		= BIT(6),
 };
 
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+struct console_atomic_data {
+	u64	seq;
+	char	*text;
+	char	*ext_text;
+	char	*dropped_text;
+};
+#endif
+
 /**
  * struct console - The console descriptor structure
  * @name:		The name of the console driver
@@ -189,6 +198,7 @@ enum cons_flags {
 struct console {
 	char			name[16];
 	void			(*write)(struct console *co, const char *s, unsigned int count);
+	void			(*write_atomic)(struct console *, const char *, unsigned);
 	int			(*read)(struct console *co, char *s, unsigned int count);
 	struct tty_driver	*(*device)(struct console *co, int *index);
 	void			(*unblank)(void);
@@ -201,7 +211,10 @@ struct console {
 	uint			ispeed;
 	uint			ospeed;
 	u64			seq;
-	unsigned long		dropped;
+	atomic_long_t		dropped;
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+	struct console_atomic_data *atomic_data;
+#endif
 	struct task_struct	*thread;
 	bool blocked;
 	/*
@@ -349,6 +362,7 @@ extern int console_set_on_cmdline;
 extern struct console *early_console;
 
 enum con_flush_mode {
+	CONSOLE_ATOMIC_FLUSH_PENDING,
 	CONSOLE_FLUSH_PENDING,
 	CONSOLE_REPLAY_ALL,
 };
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -1607,6 +1607,10 @@ config PRINTK
 	  very difficult to diagnose system problems, saying N here is
 	  strongly discouraged.
 
+config HAVE_ATOMIC_CONSOLE
+	bool
+	default n
+
 config BUG
 	bool "BUG() support" if EXPERT
 	default y
--- a/kernel/panic.c
+++ b/kernel/panic.c
@@ -325,7 +325,6 @@ void panic(const char *fmt, ...)
 		panic_smp_self_stop();
 
 	console_verbose();
-	bust_spinlocks(1);
 	va_start(args, fmt);
 	len = vscnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
@@ -342,6 +341,11 @@ void panic(const char *fmt, ...)
 		dump_stack();
 #endif
 
+	/* If atomic consoles are available, flush the kernel log. */
+	console_flush_on_panic(CONSOLE_ATOMIC_FLUSH_PENDING);
+
+	bust_spinlocks(1);
+
 	/*
 	 * If kgdb is enabled, give it a chance to run before we stop all
 	 * the other CPUs or else we won't be able to debug processes left
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -44,6 +44,7 @@
 #include <linux/irq_work.h>
 #include <linux/ctype.h>
 #include <linux/uio.h>
+#include <linux/clocksource.h>
 #include <linux/sched/clock.h>
 #include <linux/sched/debug.h>
 #include <linux/sched/task_stack.h>
@@ -2479,6 +2480,59 @@ asmlinkage __visible int _printk(const c
 }
 EXPORT_SYMBOL(_printk);
 
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+static void __free_atomic_data(struct console_atomic_data *d)
+{
+}
+
+static void free_atomic_data(struct console_atomic_data *d)
+{
+	int count = 1;
+	int i;
+
+	if (!d)
+		return;
+
+#ifdef CONFIG_HAVE_NMI
+	count = 2;
+#endif
+
+	for (i = 0; i < count; i++)
+		__free_atomic_data(&d[i]);
+	kfree(d);
+}
+
+static int __alloc_atomic_data(struct console_atomic_data *d, short flags)
+{
+	return 0;
+}
+
+static struct console_atomic_data *alloc_atomic_data(short flags)
+{
+	struct console_atomic_data *d;
+	int count = 1;
+	int i;
+
+#ifdef CONFIG_HAVE_NMI
+	count = 2;
+#endif
+
+	d = kzalloc(sizeof(*d) * count, GFP_KERNEL);
+	if (!d)
+		goto err_out;
+
+	for (i = 0; i < count; i++) {
+		if (__alloc_atomic_data(&d[i], flags) != 0)
+			goto err_out;
+	}
+
+	return d;
+err_out:
+	free_atomic_data(d);
+	return NULL;
+}
+#endif /* CONFIG_HAVE_ATOMIC_CONSOLE */
+
 static bool pr_flush(int timeout_ms, bool reset_on_progress);
 static bool __pr_flush(struct console *con, int timeout_ms, bool reset_on_progress);
 
@@ -2492,6 +2546,8 @@ static void printk_start_kthread(struct
 #define prb_first_valid_seq(rb)		0
 #define prb_next_seq(rb)		0
 
+#define free_atomic_data(d)
+
 static u64 syslog_seq;
 
 static size_t record_print_text(const struct printk_record *r,
@@ -2832,9 +2888,21 @@ static bool abandon_console_lock_in_pani
  *
  * Requires the console_srcu_read_lock.
  */
-static inline bool console_is_usable(struct console *con)
+static inline bool console_is_usable(struct console *con, bool atomic_printing)
 {
-	short flags = console_srcu_read_flags(con);
+	short flags;
+
+	if (atomic_printing) {
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+		if (!con->write_atomic)
+			return false;
+		if (!con->atomic_data)
+			return false;
+#else
+		return false;
+#endif
+	}
+	flags = console_srcu_read_flags(con);
 
 	if (!(flags & CON_ENABLED))
 		return false;
@@ -2859,7 +2927,7 @@ static bool console_is_usable_unlocked(s
 	bool ret;
 
 	cookie = console_srcu_read_lock();
-	ret = console_is_usable(con);
+	ret = console_is_usable(con, false);
 	console_srcu_read_unlock(cookie);
 
 	return ret;
@@ -2885,6 +2953,66 @@ static void __console_unlock(void)
 	up_console_sem();
 }
 
+static u64 read_console_seq(struct console *con)
+{
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+	unsigned long flags;
+	u64 seq2;
+	u64 seq;
+
+	if (!con->atomic_data)
+		return con->seq;
+
+	printk_cpu_sync_get_irqsave(flags);
+
+	seq = con->seq;
+	seq2 = con->atomic_data[0].seq;
+	if (seq2 > seq)
+		seq = seq2;
+#ifdef CONFIG_HAVE_NMI
+	seq2 = con->atomic_data[1].seq;
+	if (seq2 > seq)
+		seq = seq2;
+#endif
+
+	printk_cpu_sync_put_irqrestore(flags);
+
+	return seq;
+#else /* CONFIG_HAVE_ATOMIC_CONSOLE */
+	return con->seq;
+#endif
+}
+
+static void write_console_seq(struct console *con, u64 val, bool atomic_printing)
+{
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+	unsigned long flags;
+	u64 *seq;
+
+	if (!con->atomic_data) {
+		con->seq = val;
+		return;
+	}
+
+	printk_cpu_sync_get_irqsave(flags);
+
+	if (atomic_printing) {
+		seq = &con->atomic_data[0].seq;
+#ifdef CONFIG_HAVE_NMI
+		if (in_nmi())
+			seq = &con->atomic_data[1].seq;
+#endif
+	} else {
+		seq = &con->seq;
+	}
+	*seq = val;
+
+	printk_cpu_sync_put_irqrestore(flags);
+#else /* CONFIG_HAVE_ATOMIC_CONSOLE */
+	con->seq = val;
+#endif
+}
+
 /*
  * Prepend the message in @pmsg->pbufs->outbuf with a "dropped message". This
  * is achieved by shifting the existing message over and inserting the dropped
@@ -3028,7 +3156,8 @@ static bool printk_get_next_message(stru
  *
  * Requires the console_lock and the SRCU read lock.
  */
-static bool __console_emit_next_record(struct console *con, bool *handover, int cookie)
+static bool __console_emit_next_record(struct console *con, bool *handover,
+				       int cookie, bool atomic_printing)
 {
 	static struct printk_buffers pbufs;
 
@@ -3038,25 +3167,27 @@ static bool __console_emit_next_record(s
 		.pbufs = &pbufs,
 	};
 	unsigned long flags;
+	unsigned long dropped = 0;
+	u64 seq;
 
 	if (handover)
 		*handover = false;
 
-	if (!printk_get_next_message(&pmsg, con->seq, is_extended, true))
+	seq = read_console_seq(con);
+	if (!printk_get_next_message(&pmsg, seq, is_extended, true))
 		return false;
 
-	con->dropped += pmsg.dropped;
+	atomic_long_add((unsigned long)(pmsg.dropped), &con->dropped);
 
 	/* Skip messages of formatted length 0. */
 	if (pmsg.outbuf_len == 0) {
-		con->seq = pmsg.seq + 1;
+		write_console_seq(con, pmsg.seq + 1, atomic_printing);
 		goto skip;
 	}
 
-	if (con->dropped && !is_extended) {
-		console_prepend_dropped(&pmsg, con->dropped);
-		con->dropped = 0;
-	}
+	dropped = atomic_long_xchg_relaxed(&con->dropped, 0);
+	if (dropped && !is_extended)
+		console_prepend_dropped(&pmsg, dropped);
 
 	if (handover) {
 		/*
@@ -3077,9 +3208,12 @@ static bool __console_emit_next_record(s
 	}
 
 	/* Write everything out to the hardware. */
-	con->write(con, outbuf, pmsg.outbuf_len);
+	if (atomic_printing)
+		con->write_atomic(con, outbuf, pmsg.outbuf_len);
+	else
+		con->write(con, outbuf, pmsg.outbuf_len);
 
-	con->seq = pmsg.seq + 1;
+	write_console_seq(con, pmsg.seq + 1, atomic_printing);
 	if (handover) {
 		start_critical_timings();
 
@@ -3111,7 +3245,7 @@ static bool console_emit_next_record_tra
 		handover = NULL;
 	}
 
-	return __console_emit_next_record(con, handover, cookie);
+	return __console_emit_next_record(con, handover, cookie, false);
 }
 
 /*
@@ -3158,7 +3292,7 @@ static bool console_flush_all(bool do_co
 		for_each_console_srcu(con) {
 			bool progress;
 
-			if (!console_is_usable(con))
+			if (!console_is_usable(con, false))
 				continue;
 			any_usable = true;
 
@@ -3196,6 +3330,57 @@ static bool console_flush_all(bool do_co
 	return false;
 }
 
+#if defined(CONFIG_HAVE_ATOMIC_CONSOLE) && defined(CONFIG_PRINTK)
+static bool console_emit_next_record(struct console *con, bool atomic_printing);
+
+static void atomic_console_flush_all(void)
+{
+	unsigned long flags;
+	struct console *con;
+	bool any_progress;
+	int index = 0;
+
+	if (console_suspended)
+		return;
+
+#ifdef CONFIG_HAVE_NMI
+	if (in_nmi())
+		index = 1;
+#endif
+
+	printk_cpu_sync_get_irqsave(flags);
+
+	do {
+		int cookie;
+
+		any_progress = false;
+
+		cookie = console_srcu_read_lock();
+		for_each_console_srcu(con) {
+			bool progress;
+
+			if (!console_is_usable(con, true))
+				continue;
+
+			progress = console_emit_next_record(con, true);
+			if (!progress)
+				continue;
+			any_progress = true;
+
+			touch_softlockup_watchdog_sync();
+			clocksource_touch_watchdog();
+			rcu_cpu_stall_reset();
+			touch_nmi_watchdog();
+		}
+		console_srcu_read_unlock(cookie);
+	} while (any_progress);
+
+	printk_cpu_sync_put_irqrestore(flags);
+}
+#else /* CONFIG_HAVE_ATOMIC_CONSOLE && CONFIG_PRINTK */
+#define atomic_console_flush_all()
+#endif
+
 /**
  * console_unlock - unblock the console subsystem from printing
  *
@@ -3320,6 +3505,11 @@ void console_unblank(void)
  */
 void console_flush_on_panic(enum con_flush_mode mode)
 {
+	if (mode == CONSOLE_ATOMIC_FLUSH_PENDING) {
+		atomic_console_flush_all();
+		return;
+	}
+
 	/*
 	 * If someone else is holding the console lock, trylock will fail
 	 * and may_schedule may be set.  Ignore and proceed to unlock so
@@ -3344,7 +3534,7 @@ void console_flush_on_panic(enum con_flu
 			 * unsynchronized assignment. But in that case, the
 			 * kernel is in "hope and pray" mode anyway.
 			 */
-			c->seq = seq;
+			write_console_seq(c, seq, false);
 		}
 		console_srcu_read_unlock(cookie);
 	}
@@ -3508,11 +3698,11 @@ static void console_init_seq(struct cons
 	if (newcon->flags & (CON_PRINTBUFFER | CON_BOOT)) {
 		/* Get a consistent copy of @syslog_seq. */
 		mutex_lock(&syslog_lock);
-		newcon->seq = syslog_seq;
+		write_console_seq(newcon, syslog_seq, false);
 		mutex_unlock(&syslog_lock);
 	} else {
 		/* Begin with next message added to ringbuffer. */
-		newcon->seq = prb_next_seq(prb);
+		write_console_seq(newcon, prb_next_seq(prb), false);
 
 		/*
 		 * If any enabled boot consoles are due to be unregistered
@@ -3654,10 +3844,13 @@ void register_console(struct console *ne
 		newcon->flags &= ~CON_PRINTBUFFER;
 	}
 
-	newcon->dropped = 0;
+	atomic_long_set(&newcon->dropped, 0);
 	newcon->thread = NULL;
 	newcon->blocked = true;
 	mutex_init(&newcon->lock);
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+	newcon->atomic_data = NULL;
+#endif
 
 	console_init_seq(newcon, bootcon_registered);
 
@@ -3769,6 +3962,10 @@ static int unregister_console_locked(str
 	if (thd)
 		kthread_stop(thd);
 
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+	free_atomic_data(console->atomic_data);
+#endif
+
 	if (console->exit)
 		res = console->exit(console);
 
@@ -3958,7 +4155,7 @@ static bool __pr_flush(struct console *c
 		for_each_console_srcu(c) {
 			if (con && con != c)
 				continue;
-			if (!console_is_usable(c))
+			if (!console_is_usable(c, false))
 				continue;
 			printk_seq = c->seq;
 			if (printk_seq < seq)
@@ -4032,9 +4229,9 @@ static void __printk_fallback_preferred_
  *
  * See __console_emit_next_record() for argument and return details.
  */
-static bool console_emit_next_record(struct console *con)
+static bool console_emit_next_record(struct console *con, bool atomic_printing)
 {
-	return __console_emit_next_record(con, NULL, 0);
+	return __console_emit_next_record(con, NULL, 0, atomic_printing);
 }
 
 static bool printer_should_wake(struct console *con, u64 seq)
@@ -4062,6 +4259,11 @@ static int printk_kthread_func(void *dat
 	u64 seq = 0;
 	int error;
 
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+	if (con->write_atomic)
+		con->atomic_data = alloc_atomic_data(con->flags);
+#endif
+
 	con_printk(KERN_INFO, con, "printing thread started\n");
 	for (;;) {
 		/*
@@ -4116,7 +4318,7 @@ static int printk_kthread_func(void *dat
 		 * which can conditionally invoke cond_resched().
 		 */
 		console_may_schedule = 0;
-		console_emit_next_record(con);
+		console_emit_next_record(con, false);
 
 		seq = con->seq;
 
