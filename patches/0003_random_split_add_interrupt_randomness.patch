From: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Subject: random: Split add_interrupt_randomness().
Date: Tue, 07 Dec 2021 13:17:35 +0100

Split add_interrupt_randomness() into two parts:
- add_interrupt_randomness() which collects the entropy on the
  invocation of a hardware interrupt and it feeds into the fast_pool,
  a per-CPU variable (irq_randomness).

- process_interrupt_randomness_pool() which feeds the fast_pool/
  irq_randomness into the entropy_store if enough entropy has been
  gathered.

This is a preparations step to ease PREEMPT_RT support.

Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Link: https://lore.kernel.org/r/20211207121737.2347312-4-bigeasy@linutronix.de
---
 drivers/char/random.c |   51 +++++++++++++++++++++++++++-----------------------
 1 file changed, 28 insertions(+), 23 deletions(-)

--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -1220,6 +1220,33 @@ static u32 get_reg(struct fast_pool *f,
 	return *ptr;
 }
 
+static void process_interrupt_randomness_pool(struct fast_pool *fast_pool)
+{
+	if (unlikely(crng_init == 0)) {
+		if ((fast_pool->count >= 64) &&
+		    crng_fast_load((u8 *)fast_pool->pool, sizeof(fast_pool->pool)) > 0) {
+			fast_pool->count = 0;
+			fast_pool->last = jiffies;
+		}
+		return;
+	}
+
+	if ((fast_pool->count < 64) && !time_after(jiffies, fast_pool->last + HZ))
+		return;
+
+	if (!spin_trylock(&input_pool.lock))
+		return;
+
+	fast_pool->last = jiffies;
+	__mix_pool_bytes(&fast_pool->pool, sizeof(fast_pool->pool));
+	spin_unlock(&input_pool.lock);
+
+	fast_pool->count = 0;
+
+	/* award one bit for the contents of the fast pool */
+	credit_entropy_bits(1);
+}
+
 void add_interrupt_randomness(int irq)
 {
 	struct fast_pool *fast_pool = this_cpu_ptr(&irq_randomness);
@@ -1243,29 +1270,7 @@ void add_interrupt_randomness(int irq)
 	fast_mix(fast_pool);
 	add_interrupt_bench(cycles);
 
-	if (unlikely(crng_init == 0)) {
-		if ((fast_pool->count >= 64) &&
-		    crng_fast_load((u8 *)fast_pool->pool, sizeof(fast_pool->pool)) > 0) {
-			fast_pool->count = 0;
-			fast_pool->last = now;
-		}
-		return;
-	}
-
-	if ((fast_pool->count < 64) && !time_after(now, fast_pool->last + HZ))
-		return;
-
-	if (!spin_trylock(&input_pool.lock))
-		return;
-
-	fast_pool->last = now;
-	__mix_pool_bytes(&fast_pool->pool, sizeof(fast_pool->pool));
-	spin_unlock(&input_pool.lock);
-
-	fast_pool->count = 0;
-
-	/* award one bit for the contents of the fast pool */
-	credit_entropy_bits(1);
+	process_interrupt_randomness_pool(fast_pool);
 }
 EXPORT_SYMBOL_GPL(add_interrupt_randomness);
 
